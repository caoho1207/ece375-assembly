% template created by: Russell Haering. arr. Joseph Crop
\documentclass[12pt,letterpaper]{article}
\usepackage{anysize}
\marginsize{2cm}{2cm}{1cm}{1cm}

\begin{document}

\begin{titlepage}
    \vspace*{4cm}
    \begin{flushright}
    {\huge
        ECE 375 Lab 3\\[1cm]
    }
    {\large
        Data Manipulation and the LCD Display
    }
    \end{flushright}
    \begin{flushleft}
    Lab Time: Wednesday 5-7
    \end{flushleft}
    \begin{flushright}
    Sean Rettig
    David Winkler
    \vfill
    \rule{5in}{.5mm}\\
    TA Signature
    \end{flushright}

\end{titlepage}

\section{Introduction}

The purpose of the third lab was not only to acquaint ourselves with the concepts associated with using the AVR's LCD display, but also programming the AVR in general using assembly, being the first time we have done so.  In particular, we learned about initializing the stack pointer and copying data from program memory to data memory.

\section{Program Overview}

This is a fairly simple program that just loads two predefined strings and displays them on the LCD display.

\subsection{Initialization Routine}

The stack pointer is first initialized so that that stack can be used.  Then the LCD display initialization subroutine is called, and our two strings are transferred from program memory to data memory in two separate loops.  Each loop first loads the program memory address into the Z register and the data memory address that the LCD screen reads from into the Y register.  Then the data is transferred from where Z points to where Y points byte-by-byte using an intermediate register and post-incrementing Z and Y.  This continues until the entire string has been copied.

\subsection{Main Routine}

Since all of our data has already been copied to the proper location in data memory by the time the main routine executes, all that is left to be done is call the "LCDWrite" routine to read the strings from data memory and write them to the LDC Display.  The program then enters an infinite loop so that it doesn't continue executing the rest of program memory (which contains things like our strings).

\section{Additional Questions}
\begin{enumerate}

    \item Take a look at the code you downloaded for todayâ€™s lab. Notice the
        lines that begin with .def and .equ followed by some type of
        expression. These are known as pre-compiler directives. Define
        pre-compiler directive. What is the difference between the .def and
        .equ directives? (HINT: see section 5.1 of the AVR Starter Guide given
        on the lab webpage.)

        Pre-compiler directives are instructions specifically for the compiler
        that are executed during the build process (and not on the AVR).
        According to the AVR Starter Guide, a '.def' directive defines a
        symbolic name on a register, while a '.equ' directive sets a symbol
        equal to an expression.

    \item In this lab, you were asked to manipulate data by moving it around in
        memory. In fact, the AVR architecture has two different memories, a
        program memory and data memory. Briefly explain the differences and
        purposes of these memories within your write up.

        The program memory is only writable while flashing the AVR using the
        programmer, and is otherwise read-only, such as when code is executing.
        It holds the contents of programs as well as any constants embedded in
        the program using .DB and/or .DW pre-compiler directives.  The data
        memory is where all other data is stored, and is both readable and
        writeable.  The GPRs and IO registers are also part of the data memory
        addressing scheme.  However, the data memory is only 4KB, while program
        memory is 128KB.

    \item You also learned how to make function calls. Explain how the function
        call works, its connection to the memory stack, and why a RET
        instruction must be called to return from a function. To help you
        understand, comment out the stack pointer initialization in the
        beginning of the code and try running the program. Observe and comment
        on this behavior.

        Function calls begin with the "CALL" or "RCALL" instruction with an
        address to the beginning of a subroutine in program memory as the
        operand.  This then places the current program memory location on the
        stack and sets the program counter (PC) equal to the new address,
        effectively causing the flow of execution to continue at the beginning
        of the called function/subroutine.  Once the subroutine is finished, it
        uses a RET instruction to pop the address from the stack and load it
        back into PC, returning program execution to where it left off before
        the function call.

\end{enumerate}

\section{Conclusion}

\section{Source Code}

\begin{verbatim}
\end{verbatim}

\pagebreak

\section{Challenge Source Code}

\begin{verbatim}
\end{verbatim}

\end{document}
